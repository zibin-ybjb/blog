<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.37">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>let/const/var 的区别 | 子斌的前端分享</title><meta name="description" content="Just playing around">
    <link rel="modulepreload" href="/blog/assets/app.f7c18c03.js"><link rel="modulepreload" href="/blog/assets/let_const_var的区别.html.49bfd5e8.js"><link rel="modulepreload" href="/blog/assets/let_const_var的区别.html.a37aa8d1.js">
    <link rel="stylesheet" href="/blog/assets/style.bdd3bf52.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><!----><span class="site-name">子斌的前端分享</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">JavaScript <span class="down arrow"></span></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="let/const/var 的区别"><!--[--><!--]--> let/const/var 的区别 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#var" class="router-link-active router-link-exact-active sidebar-item" aria-label="var"><!--[--><!--]--> var <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#var-的作用域" class="router-link-active router-link-exact-active sidebar-item" aria-label="var 的作用域"><!--[--><!--]--> var 的作用域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#var-的变量提升" class="router-link-active router-link-exact-active sidebar-item" aria-label="var 的变量提升"><!--[--><!--]--> var 的变量提升 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#var-的问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="var 的问题"><!--[--><!--]--> var 的问题 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#let" class="router-link-active router-link-exact-active sidebar-item" aria-label="let"><!--[--><!--]--> let <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#let-是块级作用域" class="router-link-active router-link-exact-active sidebar-item" aria-label="let 是块级作用域"><!--[--><!--]--> let 是块级作用域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#let-可以被修改但是不能被重新声明" class="router-link-active router-link-exact-active sidebar-item" aria-label="let 可以被修改但是不能被重新声明."><!--[--><!--]--> let 可以被修改但是不能被重新声明. <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#let-的变量提升" class="router-link-active router-link-exact-active sidebar-item" aria-label="let 的变量提升"><!--[--><!--]--> let 的变量提升 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#const" class="router-link-active router-link-exact-active sidebar-item" aria-label="const"><!--[--><!--]--> const <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#const-声明的变量在块级作用域内" class="router-link-active router-link-exact-active sidebar-item" aria-label="const 声明的变量在块级作用域内"><!--[--><!--]--> const 声明的变量在块级作用域内 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#const-不能被修改并且不能被重新声明" class="router-link-active router-link-exact-active sidebar-item" aria-label="const 不能被修改并且不能被重新声明"><!--[--><!--]--> const 不能被修改并且不能被重新声明 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/JavaScript/let,const,var%E7%9A%84%E5%8C%BA%E5%88%AB.html#const-的变量提升" class="router-link-active router-link-exact-active sidebar-item" aria-label="const 的变量提升"><!--[--><!--]--> const 的变量提升 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/blog/JavaScript/new%20%E6%93%8D%E4%BD%9C%E7%AC%A6.html" class="sidebar-item" aria-label="new 操作符"><!--[--><!--]--> new 操作符 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">计算机网络 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP.html" class="sidebar-item" aria-label="HTTP协议"><!--[--><!--]--> HTTP协议 <!--[--><!--]--></a><!----></li><li><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP.html" class="sidebar-item" aria-label="TCP/IP协议"><!--[--><!--]--> TCP/IP协议 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="let-const-var-的区别" tabindex="-1"><a class="header-anchor" href="#let-const-var-的区别" aria-hidden="true">#</a> let/const/var 的区别</h1><h2 id="var" tabindex="-1"><a class="header-anchor" href="#var" aria-hidden="true">#</a> var</h2><blockquote><p>在 ES6 出现之前，必须使用 var 声明。</p></blockquote><h3 id="var-的作用域" tabindex="-1"><a class="header-anchor" href="#var-的作用域" aria-hidden="true">#</a> var 的作用域</h3><blockquote><p>作用域本质上是指变量/函数可供访问的范围。 var 可以在全局范围声明或函数/局部范围内声明。 当在最外层函数的外部声明 var 变量时，作用域是全局的。 这意味着在最外层函数的外部用 var 声明的任何变量都可以在 windows 中使用。 当在函数中声明 var 时，作用域是局部的。 这意味着它只能在函数内访问。</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">newFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里，greeter 是全局范围的，因为它存在于函数外部，而 hello 是函数范围的。 因此，我们无法在函数外部访问变量 hello。 因此，如果我们这样做：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> tester <span class="token operator">=</span> <span class="token string">&#39;hey hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">newFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: hello is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们会收到错误消息，这是由于函数外部没有 hello 导致的。</p><p>var 变量可以重新声明和修改 这意味着我们可以在相同的作用域内执行下面的操作，并且不会出错</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&#39;hey hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>又比如</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&#39;hey hi&#39;</span><span class="token punctuation">;</span>
greeter <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="var-的变量提升" tabindex="-1"><a class="header-anchor" href="#var-的变量提升" aria-hidden="true">#</a> var 的变量提升</h3><p>变量提升是 JavaScript 的一种机制:在执行代码之前，变量和函数声明会移至其作用域的顶部。 这意味着如果我们这样做:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&#39;say hello&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>生面的代码会被解释为:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> greeter<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// greeter is undefined</span>
greeter <span class="token operator">=</span> <span class="token string">&#39;say hello&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>因此，将 var 声明的变量会被提升到其作用域的顶部，并使用 undefined 值对其进行初始化.</p><h3 id="var-的问题" tabindex="-1"><a class="header-anchor" href="#var-的问题" aria-hidden="true">#</a> var 的问题</h3><p>var 有一个弱点。 我将使用以下示例进行说明：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> times <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">)</span> <span class="token comment">// &quot;say Hello instead&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>由于 times&gt; 3 返回 true，因此将 greeter 重新定义为 saysay Hello。 如果你有是故意重新定义 greeter，这段代码是问题的，但是当你不知道之前已经定义了变量 greeter 时，这将成为产生问题。</p><p>如果在代码的其他部分使用了 greeter,这可能会导致代码中出现许多错误。 这就是为什么需要 let 和 const 的原因。</p><h2 id="let" tabindex="-1"><a class="header-anchor" href="#let" aria-hidden="true">#</a> let</h2><p>let 现在已经成为变量声明的首选。 这并不奇怪，因为它是对 var 声明的改进。 它也解决了我们刚刚介绍的 var 问题。 让我们考虑一下为什么会这样。</p><h3 id="let-是块级作用域" tabindex="-1"><a class="header-anchor" href="#let-是块级作用域" aria-hidden="true">#</a> let 是块级作用域</h3><p>块是由 {} 界定的代码块,大括号中有一个块.大括号内的任何内容都包含在一个块级作用域中.</p><p>因此，在带有 let 的块中声明的变量仅可在该块中使用。 让我用一个例子解释一下</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> times <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;say Hello instead&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们看到在其代码块（定义它的花括号）之外使用 hello 会返回错误。 这是因为 let 变量是块范围的.</p><h3 id="let-可以被修改但是不能被重新声明" tabindex="-1"><a class="header-anchor" href="#let-可以被修改但是不能被重新声明" aria-hidden="true">#</a> let 可以被修改但是不能被重新声明.</h3><p>就像 var 一样，用 let 声明的变量可以在其范围内被修改。 但与 var 不同的是，let 变量无法在其作用域内被重新声明。 来看下面的栗子:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
greeting <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码将会返回一个错误:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span> <span class="token comment">// error: Identifier &#39;greeting&#39; has already been declared</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但是，如果在不同的作用域中定义了相同的变量，则不会有错误:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;say Hello instead&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;say Hi&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>为什么没有错误？ 这是因为两个实例的作用域不同，因此它们会被视为不同的变量。</p><p>这个事实说明:使用 let,是比 var 更好的选择。 当使用 let 时，你不必费心思考 🤔 变量的名称，因为变量仅在其块级作用域内存在。</p><p>同样，由于在一个块级作用域内不能多次声明一个变量，因此不会发生前面讨论的 var 出现的问题。</p><h3 id="let-的变量提升" tabindex="-1"><a class="header-anchor" href="#let-的变量提升" aria-hidden="true">#</a> let 的变量提升</h3><p>就像 var 一样，let 声明也被提升到作用域顶部。 但不同的是:</p><p>用 var 声明的变量会被提升到其作用域的顶部，并使用 undefined 值对其进行初始化。 用 let 声明的变量会被提升到其作用域的顶部，不会对值进行初始化。 因此，如果你尝试在声明前使用 let 变量，则会收到 Reference Error。</p><h2 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h2><p>用 const 声明的变量保持常量值。 const 声明与 let 声明有一些相似之处</p><h3 id="const-声明的变量在块级作用域内" tabindex="-1"><a class="header-anchor" href="#const-声明的变量在块级作用域内" aria-hidden="true">#</a> const 声明的变量在块级作用域内</h3><p>像 let 声明一样，const 声明只能在声明它们的块级作用域中访问</p><h3 id="const-不能被修改并且不能被重新声明" tabindex="-1"><a class="header-anchor" href="#const-不能被修改并且不能被重新声明" aria-hidden="true">#</a> const 不能被修改并且不能被重新声明</h3><p>这意味着用 const 声明的变量的值保持不变。 不能修改或重新声明。 因此，如果我们使用 const 声明变量，那么我们将无法做到这一点:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
greeting <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span> <span class="token comment">// error: Assignment to constant variable.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或者这个这样:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span> <span class="token comment">// error: Identifier &#39;greeting&#39; has already been declared</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>因此，每个 const 声明都必须在声明时进行初始化。</p><p>当用 const 声明对象时，这种行为却有所不同。 虽然不能更新 const 对象，但是可以更新该对象的属性。 因此，如果我们声明一个 const 对象为</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;say Hi&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">times</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>同样不能像下面这样做:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">words</span><span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token string">&#39;five&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// error:  Assignment to constant variable.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但我们可以这样做:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>greeting<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&#39;say Hello instead&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这将更新 greeting.message 的值，而不会返回错误。</p><h3 id="const-的变量提升" tabindex="-1"><a class="header-anchor" href="#const-的变量提升" aria-hidden="true">#</a> const 的变量提升</h3><p>就像 let 一样，const 声明也被提升到顶部，但是没有初始化。</p><p>最后，我们总结一下它们的异同：</p><ul><li>var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。</li><li>var 变量可以在其范围内更新和重新声明； let 变量可以被更新但不能重新声明； const 变量既不能更新也不能重新声明。</li><li>它们都被提升到其作用域的顶端。 但是，虽然使用变量 undefined 初始化了 var 变量，但未初始化 let 和 const 变量。</li><li>尽管可以在不初始化的情况下声明 var 和 let，但是在声明期间必须初始化 const。</li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: liuzibin2021@126.com">zibin</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/blog/JavaScript/new%20%E6%93%8D%E4%BD%9C%E7%AC%A6.html" class="" aria-label="new 操作符"><!--[--><!--]--> new 操作符 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.f7c18c03.js" defer></script>
  </body>
</html>
